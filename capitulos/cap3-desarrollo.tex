% Idea general

% \begin{itemize}
%     \item Parser C3D
%     \item Entorno Bevy
%     \item creación configuraciones (toml)
% \end{itemize}


\chapter{Desarrollo} \label{sec:cap3}

\noindent Este proyecto se ha llevado a cabo en diferentes etapas. En un comienzo, se trabaja con un fichero \ac{C3D} capturado por las cámaras de INEF, con el sistema de captura de datos de la marca Vicon explicado en el \autoref{sec:cap2}. Estos datos de entrada consisten en una grabación a 240 Hz de un \textit{swing} de golf\footnote{Un swing de golf es la acción mediante la cual los jugadores golpean la pelota en este deporte \autocite{GolfSwing2025}}. 

Como se ha explicado en el \autoref{sec:ficheros-c3d}, un \ac{C3D} es un fichero binario que contiene la posición de diferentes marcadores en el tiempo. Por tanto, no es difícil convertir estos datos en un formato de texto legible. Se muestra en la \autoref{tab:c3d_data} un fragmento de un fichero \ac{C3D} que se ha utilizado durante el desarrollo de la aplicación convertido a una tabla:

\begin{table}[htbp]
  \centering
  \setlength{\tabcolsep}{5pt}
  \renewcommand{\arraystretch}{1.2}
  \rowcolors{3}{white}{gray!10}
  \begin{tabular}{r|S[table-format=-3.2]S[table-format=-3.2]S[table-format=-3.2]|S[table-format=-3.2]S[table-format=-3.2]S[table-format=-3.2]}
  \toprule
  \multirow{2}{*}{\textbf{Frame}} & \multicolumn{3}{c|}{RFIN                          } & \multicolumn{3}{c}{RFRA                          } \\
    & {\textbf{x}} & {\textbf{y}} & {\textbf{z}} & {\textbf{x}} & {\textbf{y}} & {\textbf{z}} \\
  \midrule
  1 & 46.80 & 3.25 & 664.41 & -23.14 & -4.06 & 827.33 \\
  2 & 46.80 & 3.25 & 664.41 & -23.14 & -4.07 & 827.30 \\
  3 & 46.80 & 3.25 & 664.41 & -23.14 & -4.08 & 827.30 \\
  4 & 46.80 & 3.25 & 664.41 & -23.14 & -4.07 & 827.30 \\
  5 & 46.80 & 3.25 & 664.41 & -23.15 & -4.06 & 827.31 \\
  \midrule
  6 & 46.80 & 3.25 & 664.41 & -23.16 & -4.03 & 827.33 \\
  7 & 46.81 & 3.25 & 664.41 & -23.18 & -4.00 & 827.35 \\
  8 & 46.82 & 3.28 & 664.40 & -23.21 & -3.99 & 827.36 \\
  9 & 46.87 & 3.36 & 664.40 & -23.23 & -4.02 & 827.33 \\
  10 & 46.93 & 3.51 & 664.38 & -23.23 & -4.09 & 827.26 \\
  \bottomrule
  \end{tabular}
  \caption{Fragmento de un fichero C3D convertido a tabla}
  \label{tab:c3d_data}
\end{table}

Se puede observar que aparecen dos marcadores, \ac{RFIN} y \ac{RFRA}, con sus coordenadas en el espacio, representadas por los valores de las columnas \textit{x}, \textit{y} y \textit{z}, en unidades de milímetros.

\section{\textit{Parser} \acs{C3D}} \label{sec:parser-c3d}
Estos datos se deben integrar con el resto del programa. Para ello, se debe contar con un \textit{parser} que convierta trate con el binario.

Se ha partido del \textit{crate} de \textit{Rust} \texttt{bevy-c3d}. Este \textit{crate} utiliza a su vez el \textit{crate} \texttt{c3dio}, que es un \textit{parser} para ficheros C3D, pero integrado a \textit{Bevy}. De este modo, se consigue un \textit{Asset} que se puede cargar en el motor de juego.

\section{\textit{Bevy}} \label{sec:bevy}
Este proyecto usa el motor de videojuegos \textit{Bevy} como base para generar un entorno tridimensional donde representar el \ac{C3D}. Bevy sigue el paradigma \ac{ECS} \todo{Referencia}

Se muestra en la \autoref{fig:entorno3D} una imagen del entorno tridimensional creado con Bevy, antes de cargar el \ac{C3D}.


\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{imagenes/entorno3D.png}
  \caption{Entorno 3D creado con Bevy}
  \label{fig:entorno3D}
\end{figure}

En este entorno destacan el plano central, representado en un color verde oscuro, y sobre el que se apoyan 3 vectores que sirven como referencia. El código que genera estos vectores se incluye en el \autoref{apx:spawn_ref_vec}, demostrando la flexibilidad de \textit{Bevy} y el potencial de Rust. 

\section{Fichero de configuración \acs{TOML}}

El fichero de configuración de este proyecto define el modo de representación del fichero \ac{C3D} en el entorno 3D. 

Al igual que en el fichero de configuración de Vicon, explicado en \autoref{sec:ficheros-configuracion}, se definen las posibles configuraciones entre corchetes. Cualquier configuración cuenta con un grupo de puntos visibles (\textit{visible\_points}), un grupo de uniones (\textit{joins}) y un grupo de vectores (\textit{vectors}).

Estos grupos son opcionales, y pueden aparecer en cualquier orden. En caso de no aparecer, el programa no los representará.

\subsection{Configuración básica}

Una posible configuración podría ser la siguiente:

\begin{lstlisting}[style=mystyle, caption={Ejemplo simple de un fichero de configuración}, label={lst:ajuste-simple}]
[config1]
  visible_points = [
    "LFHD", "RFHD", "RBHD", "LBHD"
  ]
  joins = [
    ["LFHD", "RFHD", "RBHD", "LBHD", "LFHD"]
  ]
\end{lstlisting}

En el \autoref{lst:ajuste-simple} se muestra una configuración sencilla, \texttt{config1}, que representa los marcadores \ac{LFHD}, \ac{RFHD}, \ac{RBHD} y \ac{LBHD} como puntos visibles. Después, se define una unión entre los cuatro marcadores. Para representar un cuadrado, se duplica el primer marcador, \ac{LFHD}, al final de la lista. De este modo, se cierra la unión entre los cuatro marcadores. Además, se puede apreciar que en el grupo de uniones aparece un corchete extra. Esto se debe a que el grupo se considera una lista de listas. Las listas hijas representan diferentes uniones, es decir, grupos independientes de marcadores que se unen entre sí.

Estos cuatro marcadores representan los puntos de la cabeza. Es una combinación muy común, que posiblemente se utilice en varias configuraciones. Para facilitar su uso, el fichero de configuración permite definir un grupo de marcadores como un alias. De este modo, se puede definir el grupo de marcadores de la cabeza como \texttt{head}, y usarlo en la configuración de la siguiente manera:

\begin{lstlisting}[style=mystyle, caption={Ejemplo de un grupo de puntos}, label={lst:grupos-puntos}]
[point_groups]
  head = ["LFHD", "RFHD", "RBHD", "LBHD", "LFHD"]
  shoulders = ["LSHO", "RSHO"]

[config1]
  visible_points = [
    ["head"]
  ]
  joins = [
    [["head"]]
  ]
[config2]
  visible_points = [
    ["head"], ["shoulders"]
  ]
  joins = [
    [["head"]], 
    [["shoulders"]]
  ]
\end{lstlisting}

En el \autoref{lst:grupos-puntos} se muestra un ejemplo de cómo definir grupos de puntos, mediante la palabra reservada \textit{point\_groups}. En este caso, se definen dos grupos, \texttt{head} y \texttt{shoulders}. La forma de indicar al programa que se está referenciando a un grupo de puntos en vez de a un marcador es envolviendo al nombre entre corchetes.

En este caso, en la configuración \texttt{config1}, se representa el grupo de la cabeza como un punto visible y como una unión\footnote{Nótese que al usar el grupo de puntos de la cabeza, se está incluyendo dos veces el punto \ac{LFHD}. Esto no es relevante, dado que internamente el programa trata este punto como uno solo, al usarse como clave de un \textit{Hashmap}, que no permite la duplicación de elementos.}. En la configuración \texttt{config2}, se representan ambos grupos como puntos visibles y como uniones independientes. 

\subsection{Personalización}

El fichero de configuración permite personalizar la representación de los marcadores. Para ello, se definen una serie de palabras reservadas. Estas palabras son \texttt{point\_color}, \texttt{point\_size}, \texttt{join\_color} y \texttt{line\_thickness}. Estas palabras son opcionales, y permiten personalizar la representación de los marcadores y las uniones. Los colores se pueden definir en formato rgb, como una lista de tres números enteros entre 0 y 255, o como rgb con transparencia, como una lista de cuatro números enteros entre 0 y 255.

\begin{lstlisting}[style=mystyle, caption={Configuración personalizada}, label={lst:cfg-personalizada}]
[point_groups]
  head = ["LFHD", "RFHD", "RBHD", "LBHD", "LFHD"]
  shoulders = ["LSHO", "RSHO"]

[config1]
  visible_points = [
    ["head"]
  ]
  joins = [
    [["head"]]
  ]
  point_color = [255, 0, 0]
  join_color = [0, 0, 255]
  line_thickness = 2.0
  point_size = 1.5

[config2]
  visible_points = [
    ["head"], ["shoulders"]
  ]
  joins = [
    [["head"]], 
    [["shoulders"]]
  ]
  point_color = [0, 0, 255, 100]
  point_size = 2.0
\end{lstlisting}

En el \autoref{lst:cfg-personalizada} se muestra un ejemplo de la personalización de una configuración, sobreescribiendo los valores por defecto. En este caso, para la configuración \texttt{config1}, los marcadores se representan en rojo, y las uniones en verde. Cada línea se representa con el doble de grosor que el valor por defecto, y los marcadores tienen un tamaño 1.5 veces mayor que el valor por defecto. En la configuración \texttt{config2}, los marcadores se representan en azul, con un 40\% de transparencia, y el doble de tamaño que el valor por defecto. Las uniones no se personalizan, por lo que se usan los valores por defecto.

Lo visto en el \autoref{lst:cfg-personalizada} es un ejemplo de sobreescritura de los valores por defecto para cada configuración. Sin embargo, se puede lograr una personalización más extrema gracias a los grupos de puntos, a los que se les pueden aplicar las mismas palabras reservadas. De este modo, se pueden definir diferentes colores y tamaños para cada grupo de puntos. En el \autoref{lst:cfg-grupos-personalizados} se muestra un ejemplo de cómo personalizar los grupos de puntos:

\begin{lstlisting}[style=mystyle, caption={Configuración personalizada de grupos de puntos}, label={lst:cfg-grupos-personalizados}]
[point_groups]
  head = ["LFHD", "RFHD", "RBHD", "LBHD", "LFHD"]
  shoulders = ["LSHO", "RSHO"]

[head.config]
  point_color = [255, 0, 0]
  point_size = 0.5
  join_color = [255, 128, 0]

[config1]
  visible_points = [
    ["head"]
  ]
  joins = [
    [["head"]]
  ]
  point_color = [255, 0, 0]
  join_color = [0, 0, 255]
  line_thickness = 2.0
  point_size = 1.5

[config2]
  visible_points = [
    ["head"], ["shoulders"]
  ]
  joins = [
    [["head"]], 
    [["shoulders"]]
  ]
  point_color = [0, 0, 255, 100]
  point_size = 2.0
\end{lstlisting}

Como se puede apreciar, se utiliza el nombre del grupo de puntos seguido de \texttt{.config} para definir la configuración de ese grupo, sobreescribiendo el valor por defecto de su configuración. En este caso, el grupo de puntos \texttt{head} se representa en rojo, con un tamaño de 0.5 veces el valor por defecto, y las uniones en naranja. El grupo de puntos \texttt{shoulders} no se personaliza, por lo que se usan los valores por defecto, que será azul en \texttt{config1} y verde en \texttt{config2}, puesto que verde es el color por defecto para las uniones, y en \texttt{config2} no se está sobreescribiendo.

\subsection{Configuración de vectores}

Los vectores son similares a los vectores de referencia explicados en \autoref{sec:bevy}. En el fichero de configuración, se definen como un punto de anclaje, una lista de elementos anclados a ese marcador, y opcionalmente una escala. Los vectores permiten representar relaciones espaciales y se pueden utilizar para definir trayectorias o movimientos en el espacio tridimensional.

\begin{lstlisting}[style=mystyle, caption={Configuración de un vector}, label={lst:cfg-vector}]
[config1]
  vectors = [ 
    ["OBJ1", "LVelOBJ1"],
    ["LUarmCM", ["LUarmIv", "LUarmJv", "LUarmKv"], 2.5],
    ["RUarmCM", ["RUarmIv", "RUarmJv"], 2.5],
    ["RUarmCM", "RUarmKv", 1.5],
]
\end{lstlisting}

En el \autoref{lst:cfg-vector} se muestra un ejemplo de como configurar vectores. En este caso, se han definido tres puntos de anclaje: \texttt{OBJ1}, \texttt{LUarmCM} y \texttt{RUarmCM}. 

El primero de ellos, \texttt{OBJ1}, tiene un solo elemento anclado, \texttt{LVelOBJ1}. Esta configuración ancla el marcador de representación de la velocidad de LVelOBJ1 a OBJ1. Esto representará un vector tangente a la trayectoria del objeto en cualquier punto.

El segundo, \texttt{LUarmCM}, tiene tres elementos anclados, \texttt{LUarmIv}, \texttt{LUarmJv} y \texttt{LUarmKv}, y una escala de 2.5. Esta es una configuración estándar para la representación de un sistema de coordenadas local, que sirven para cuantificar la rotación de un marcador.

El tercero, \texttt{RUarmCM}, tiene tres elementos anclados, \texttt{RUarmIv} y \texttt{RUarmJv}, con una escala de 2.5, y posteriormente se añade el tercer elemento, \texttt{RUarmKv}, con una escala de 1.5. Similar al caso anterior, se representa un sistema de coordenadas local, pero reduciendo el tamaño de la componente K.

Los vectores tienen una configuración de color fija. Para los vectores que tienen un número diferente a tres elementos anclados, se representan en amarillo, mientras que si el número de marcadores anclados a un punto es exactamente igual a tres, el programa entiende que se trata de una representación de vectores de referencia, para lo que utiliza colores estándar en otros motores de videojuegos, representando la primera componente en rojo, la segunda en verde y la tercera en azul. 